(function () {
    'use strict';

    angular.module('demoApp')
        .factory('carServices', ['CAR_PATH', 'CAR_PATH_DISTANCE', 'CAR_ICON', 'CAR_TIME_DISTANCE', '$rootScope', '$timeout', 'gmapServices', carServices]);

    function carServices(CAR_PATH, CAR_PATH_DISTANCE, CAR_ICON, CAR_TIME_DISTANCE, $rootScope, $timeout, gmapServices) {
        var service = {};

        var carCanvasId = 'carcanvas';
        var snapToRoute = null;

        var polyline = null,
            polylinePath = []
        ;

        var img = new Image();
        img.src = CAR_ICON;

        var eol = CAR_PATH_DISTANCE,// eol is distance generated by directions service ex. result.routes[0].legs[0].distance.value
            k = 0,
            step = 5
        ;

        service.angle = 0;
        service.distanceCovered = 0

        service.carPath = CAR_PATH;

        var startCoord = new google.maps.LatLng(service.carPath[0]);
        var runCarPromise = null;

        service.defaultSpeed = 100;

        service.lastVertex = 0;
        service.speed = 100;
        service.car = null;

        service.isPaused = false;
        // force pause
        service.paused_ = false;

        service.initialize = initialize;
        service.plotCar = plotCar;
        service.runCar = runCar;
        service.startCar = startCar;
        service.resetCar = resetCar;

        service.accelerate = accelerate;

        service.accelerateCar = accelerateCar;
        service.pauseCar = pauseCar;
        service.resumeCar = resumeCar;

        service.processAngle = processAngle;

        service.changeSpeed = changeSpeed;
        service.slowDown = slowDown;
        service.accelerateCarAfter = accelerateCarAfter;


        function initialize() {
            gmapServices.initDirectionsService();

            //polyline = gmapServices.createPolyline(service.carPath);
            polyline = gmapServices.createDashedPolyline(service.carPath);
            polylinePath = polyline.getPath().getArray();
            gmapServices.showPolyline(polyline);

            //gmapServices.addMapListener('click', function (event) {
            //    console.log('Click Position: ', event.latLng.toJSON());
            //});

            service.polyline = polyline;

            //gmapServices.addListener(polyline, 'click', function (e) {
            //    console.log('Polyline clicked: ', e.latLng.toJSON());
            //    //console.log('Distance from start: ', startCoord.distanceFrom(e.latLng));
            //    gmapServices.getDirections(startCoord, e.latLng);
            //});

            //console.log('Polyline Distance: ', google.maps.geometry.spherical.computeLength(polylinePath));

            //var newPath = [];
            //service.carPath.forEach(function(latLng, index){
            //    newPath.push({
            //      position: latLng,
            //      index: index
            //    });
            //   //var marker = gmapServices.createCircleMarker(latLng);
            //   // marker.coords = latLng;
            //   //
            //   //gmapServices.addListener(marker, 'click', function(){
            //   //    console.log('Marker Position: ',this.coords);
            //   //})
            //});
            //console.log('New Path: ',JSON.stringify(newPath));

            resetCar();

            if ( !snapToRoute)
                snapToRoute = new SnapToRoute(gmapServices.map, service.car, service.polyline);

            google.maps.event.addDomListener(service.car.canvas_, 'mousedown', function () {
                snapToRoute.start();
            });

            google.maps.event.addListener(gmapServices.map, 'mouseup', function (e) {
                snapToRoute.stop();
                google.maps.event.trigger(service.car.div_, 'mouseup');


                var distance = polyline.GetDistanceAtPoint(service.car.getPosition());
                var path = getClosestTimeByDistance(distance);

                //var point = polyline.GetPointAtDistance(distance);
                if (distance > eol) {
                    service.lastVertex = 0;
                    return;
                }

                service.distanceCovered = path.distance;
                $rootScope.$broadcast('seek-video-time', {time: path.time.toString()});
            });
        }

        function resetCar() {
            var p0 = gmapServices.castToLatLngObject(service.carPath[0]),
                p1 = gmapServices.castToLatLngObject(service.carPath[1]);

            gmapServices.setMapCenter(p0);

            initCar(p0, p1);
        }


        function initCar(p0, p1) {
            if (!service.car) service.car = gmapServices.initCanvasMarker(p0, carCanvasId, CAR_ICON);
            else service.car.setPoint(p0);

            service.angle = gmapServices.computeBearing(p0, p1);

            service.car.plot(service.angle);
        }

        function calculateCarAngle(distance) {
            if (polyline.GetIndexAtDistance(distance) > service.lastVertex) {
                //console.log('last vertex: ', service.lastVertex);
                service.lastVertex = polyline.GetIndexAtDistance(distance);

                if (service.lastVertex == polylinePath.length) {
                    service.lastVertex -= 1;
                }

                while (polylinePath[service.lastVertex - 1].equals(polylinePath[service.lastVertex])) {
                    service.lastVertex -= 1;
                }

                service.angle = gmapServices.computeBearing(
                    polylinePath[service.lastVertex - 1],
                    polylinePath[service.lastVertex]
                );

                service.car.plot(service.angle);
            }
        }


        function processAngle(distance) {
            if(distance < 1) {
                resetCar();
                return;
            }

            var currentVertex = polyline.GetIndexAtDistance(distance);

            service.angle = gmapServices.computeBearing(
                polylinePath[currentVertex - 1],
                polylinePath[currentVertex]
            );

            service.car.plot(service.angle);
        }

        function plotCar(distance) {
            var point = polyline.GetPointAtDistance(distance);

            if (distance > eol || !point) {
                var msg = 'Distance: ' + (distance / 1609.344).toFixed(2) + ' miles';
                $rootScope.$broadcast('trip-completed', {message: msg});
                return;
            }

            if (k++ >= 180 / step) {
                gmapServices.panTo(point);
                k = 0;
            }

            service.car.setPoint(point);

            calculateCarAngle(distance);
        }


        function runCar(distance) {
            if (!service.isPaused && !service.paused_) {
                plotCar(distance);

                service.distanceCovered = distance + step;
            }

            runCarPromise = $timeout(function () {
                                service.runCar(service.distanceCovered);
                            }, service.speed);
        }

        function startCar() {
            if (service.isPaused || service.paused_) {
                accelerateCar();
                if(runCarPromise) return;
            }

            if (service.car && !service.car.getMap()) service.car.setMap(gmapServices.map);

            $timeout(function () {
                service.runCar(service.distanceCovered);
            }, 0);
        }

        function accelerate(speed) {
            var _speed = speed || 100;

            changeSpeed(_speed);
            service.isPaused = false;
        }

        function accelerateCar() {
            service.isPaused = false;
            service.paused_ = false;
        }

        function pauseCar(forcePause) {
            if (forcePause) service.paused_ = true;

            service.isPaused = true;
        }

        function resumeCar() {
            if (service.isPaused) {
                service.isPaused = false;
            }
        }

        function slowDown(speed) {
            if (service.isPaused) service.isPaused = false;

            changeSpeed(speed);
        }

        function changeSpeed(speed) {
            service.speed = speed;
        }

        function accelerateCarAfter(timeMillis, speed) {
            var _timeMillis = timeMillis || 2000,
                _speed = speed || 100;

            $timeout(function () {
                accelerate(_speed);
            }, _timeMillis);
        }

        function getClosestTimeByDistance(distance) {
            var curr = CAR_TIME_DISTANCE[Object.keys(CAR_TIME_DISTANCE)[0]].distance;
            var dist = 0,
                foundTime = 0;

            for(var time in CAR_TIME_DISTANCE) {
               //console.log('Time: '+time+' Distance: ', CAR_TIME_DISTANCE[time]);
                dist = CAR_TIME_DISTANCE[time].distance;
                if( Math.abs(distance - dist) < Math.abs(distance - curr)) {
                    curr = dist;
                    foundTime = time;
                }
            }

            return {
                distance: curr,
                time: foundTime
            };
        }

        return service;
    }
}());